# -*- coding: utf-8 -*-
"""Demand Forecasting in Supply Chain

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12uXLmXEulkVjqdRMaoQDV_eNjyRi5HSP

## Import File
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

df = pd.read_csv('/content/stores_sales_forecasting.csv', encoding='ISO-8859-1')
df.head()

"""# Data Pre-processing

Dataset yang tersedia bersifat granular, sehingga ada kemungkinan terdapat beberapa pesanan dalam sehari. Data perlu digabungkan untuk memperoleh total order atau sales setiap hari.
"""

print(df.columns)

# ubah tipe data Order Date
df['Order Date'] = pd.to_datetime(df['Order Date']) # ubah tipe data menjadi datetime
df_agg = df.groupby('Order Date').agg({'Sales': 'sum', 'Quantity': 'sum', 'Profit': 'sum'}) # jumlah total sales, quantity, dan profit per hari
df_agg.head()

# jumlah total sales, quantity, dan profit per bulan
monthly_sales = df_agg[['Sales','Quantity','Profit']].resample('M').sum()
monthly_sales.head()

df.info()

df.describe()

"""# Visualization"""

plt.figure(figsize=(12,6))
plt.plot(monthly_sales.index, monthly_sales['Sales'])
plt.xlabel('Order Date')
plt.ylabel('Total Sales')
plt.title('Monthly Total Sales')

plt.figure(figsize=(12,6))
plt.plot(monthly_sales.index, monthly_sales['Quantity'])
plt.xlabel('Order Date')
plt.ylabel('Total Quantity')
plt.title('Monthly Total Quantity')

plt.figure(figsize=(12,6))
plt.plot(monthly_sales.index, monthly_sales['Profit'])
plt.xlabel('Order Date')
plt.ylabel('Total Profit')
plt.title('Monthly Total Profit')

df.head()

df['Order Date'] = pd.to_datetime(df['Order Date'])

# Extract Year and Month for grouping
df['Year'] = df['Order Date'].dt.year
df['Month'] = df['Order Date'].dt.month

# berdasarkan daerah
# Aggregate sales per Year-Month for each Region
region_sales = df.groupby(['Year', 'Month', 'Region'])['Sales'].sum().reset_index()

# Convert Year-Month to a single DateTime format
region_sales['Year-Month'] = pd.to_datetime(region_sales[['Year', 'Month']].assign(day=1))

# Plot Sales Trend by Region
plt.figure(figsize=(12, 5))
sns.lineplot(data=region_sales, x='Year-Month', y='Sales', hue='Region')
plt.title('Sales Trend per Year and Month by Region')
plt.xlabel('Year-Month')
plt.ylabel('Total Sales')
plt.xticks(rotation=45)
plt.legend(title="Region")
plt.show()

# Aggregate sales per Year-Month for each Product Category
category_sales = df.groupby(['Year', 'Month', 'Sub-Category'])['Sales'].sum().reset_index()

category_sales['Year-Month'] = pd.to_datetime(category_sales[['Year', 'Month']].assign(day=1))

# Plot Sales Trend by Product Category
plt.figure(figsize=(12, 5))
sns.lineplot(data=category_sales, x='Year-Month', y='Sales', hue='Sub-Category')
plt.title('Sales Trend per Year and Month by Product Category')
plt.xlabel('Year-Month')
plt.ylabel('Total Sales')
plt.xticks(rotation=45)
plt.legend(title="Category")
plt.show()

"""# Forecasting and Evaluating with **Simple Naive Forecast Method**"""

# Recall monthly_sales variable, which consists of Sales, Quantity, and Profit
# -->

monthly_sales.head()

# Apply Naive Forecast = taking the last number/value to predict the next

monthly_sales['Simple Naive Forecast'] = monthly_sales['Sales'].shift(1)
monthly_sales.head()

from sklearn.metrics import mean_squared_error, mean_absolute_error

train_data = monthly_sales[:-12] #omit the last 12 data
test_data = monthly_sales[-12:] #take the last 12 data

print("Train Data: ")
print(train_data)
print("*"*5)
print("Test Data: ")
print(test_data)

#RMSE = Root Mean Squared Error
#MAE = Mean Absolute Error
rmse = np.sqrt(mean_squared_error(test_data['Sales'], test_data['Simple Naive Forecast'])) #actual data = test_data['Sales'], prediction = test_data['Simple Naive Forecast']
mae = mean_absolute_error(test_data['Sales'], test_data['Simple Naive Forecast'])

print(f'RMSE: {rmse}')
print(f'MAE: {mae}')

plt.figure(figsize=(12, 6))
plt.plot(monthly_sales.index, monthly_sales['Sales'], label='Actual Sales')
plt.plot(test_data.index, test_data['Simple Naive Forecast'], label='Simple Naive Forecast')
plt.legend()

"""## Seasonal Naive Forecast"""

monthly_sales['Seasonal Naive Forecast'] = monthly_sales['Sales'].shift(12)

train_data = monthly_sales[:-12]
test_data = monthly_sales[-12:]

print("Train Data: ")
print(train_data)
print("*"*5)
print("Test Data: ")
print(test_data)

#RMSE = Root Mean Squared Error
#MAE = Mean Absolute Error
rmse = np.sqrt(mean_squared_error(test_data['Sales'], test_data['Seasonal Naive Forecast']))
mae = mean_absolute_error(test_data['Sales'], test_data['Seasonal Naive Forecast'])

print(f'RMSE: {rmse}')
print(f'MAE: {mae}')

plt.figure(figsize=(12, 6))
plt.plot(monthly_sales.index, monthly_sales['Sales'], label='Actual Sales')
plt.plot(test_data.index, test_data['Seasonal Naive Forecast'], label='Seasonal Naive Forecast Sales')
plt.legend()

"""## Forecasting with ARIMA

### ADF Test for check for stationarity
"""

#ADF Test

from statsmodels.tsa.stattools import adfuller #Augmented Dickey-Fuller Test

adf_test = adfuller(monthly_sales['Sales'])
print("ADF Statistic: %f" % adf_test[0])
print('p-value: %f' % adf_test[1])

"""ADF Check:
1. ADF is a statistic test to check stationarity
2. H0: Data is non-stationary
   H1: Data is stationary

Since the P-value is < 0.05, we can interpret that the data is stationary.

### ACF Plot to see for seasonality
"""

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from sklearn.model_selection import train_test_split

plot_acf(df_agg['Sales'], lags=50)
plt.show()

from statsmodels.tsa.arima.model import ARIMA


train_data = monthly_sales[:-12]
test_data = monthly_sales[-12:]

#ARIMA(p,d,q) --> P for Autoregressive, d for differencing, q for Moving Average

model = ARIMA(train_data['Sales'], order=(13, 0, 2)) #Iterative Process, trial and error is needed
model_fit = model.fit()

# Make predictions
predictions = model_fit.predict(start=len(train_data), end=len(monthly_sales)-1) #Start parameter --> begins at the end of the length of train data


# Evaluate the model
rmse = np.sqrt(mean_squared_error(test_data['Sales'], predictions))
mae = mean_absolute_error(test_data['Sales'], predictions)

print(f'ARIMA RMSE: {rmse}')
print(f'ARIMA MAE: {mae}')

# Plot the results
plt.figure(figsize=(12, 6))
plt.plot(monthly_sales.index, monthly_sales['Sales'], label='Actual Sales')
plt.plot(test_data.index, predictions, label='ARIMA Predictions')
# plt.plot(test_data.index, test_data['Simple Naive Forecast'], label='Simple Naive Forecast')
# plt.plot(test_data.index, test_data['Seasonal Naive Forecast'], label='Seasonal Naive Forecast')
plt.legend()
plt.show()

plt.figure(figsize=(12, 6))
plt.plot(monthly_sales.index, monthly_sales['Sales'], label='Actual Sales')
plt.plot(test_data.index, predictions, label='ARIMA Predictions')
plt.plot(test_data.index, test_data['Simple Naive Forecast'], label='Simple Naive Forecast')
plt.plot(test_data.index, test_data['Seasonal Naive Forecast'], label='Seasonal Naive Forecast')
plt.legend()
plt.show()

"""## Create Prediction for 2018
Using Seasonal naive Bayes as the smallest error (RMSE / MAE) model.
"""

# Create future dates for 2018 (Month End frequency to match your resampling)
future_dates = pd.date_range(start='2018-01-31', end='2018-12-31', freq='M')

# Use seasonal naive forecast: Copy the sales from Janâ€“Dec 2017
seasonal_naive_forecast = monthly_sales.loc['2017-01-31':'2017-12-31', 'Sales'].values

# Create forecast DataFrame
predict_2018 = pd.DataFrame({'Sales Forecast': seasonal_naive_forecast}, index=future_dates)

# Plot the forecast against historical sales
plt.figure(figsize=(12, 6))
plt.plot(monthly_sales.index, monthly_sales['Sales'], label='Actual Sales')
plt.plot(predict_2018.index, predict_2018['Sales Forecast'], label='2018 Sales Forecast', linestyle='--')
plt.xlabel('Date')
plt.ylabel('Sales')
plt.title('2018 Sales Forecast using Seasonal Naive Method')
plt.legend()
plt.show()

# Show forecast table
print(predict_2018)